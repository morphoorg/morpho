
/*
* MC Beta Decay Spectrum Endpoint Model - Functions
* -----------------------------------------------------
* Author: Talia Weiss <tweiss@mit.edu>
*
* Date: 11 January 2016
*
* Purpose:
*
*   Defines functions to be used in endpoint generation and analysis models.
*
*/


//  Finds the reduced mass of a diatomic molecule

    real reduced_mass(real m1, real m2)
    {
        return m1 * m2 / (m1 + m2);
    }


//  Zero-point vibrational energy values calcuating using equations 22-24 in BPR
//  as well as H2 parameters determined by fitting to Dieke (1958) data

    real EZero_Point( real isotope_mass )
    {
	real mu;
	real hbar_omega;
	real E_zp;

	mu <- reduced_mass(isotope_mass, tritium_atomic_mass());
	hbar_omega <- hbar()*sqrt(kH2()/mu);
	E_zp <- 0.5*hbar_omega - aH2()*square(0.5*hbar_omega);

	return E_zp;

    }

//  Energy of a given rotation state J for a given isotopolog. mass_s is the mass of the atom other than tritium in the source
//  (Set mass_s = 0.0 for atomic tritium)

    real find_E_J(real mass_s, int J)
    {
        real mom_of_inertia;
	real E_J;

	E_J <- 0.;
        mom_of_inertia <- reduced_mass(mass_s, tritium_atomic_mass())* square(bond_length_H2());
        if (mass_s > 0.)  E_J <- J * (J+1) * square(hbarc()) / (2. * mom_of_inertia);

	return E_J;

    }


//  To be used to find partition function/rotation state probabilities for HT and DT

    real f_heterogenous(int J, real temperature, real mass_s)
    {
        return (2.0*J+1.0) * exp(-find_E_J(mass_s, J) / (k_boltzmann()*temperature));
    }


//  Finds translational variance for one isotopolog (Eq. 40 in BPR)
//  Here, mass_s is the mass of the atom *other than* atomic tritium in the isotopolog

    real find_sigma_squared_translational(real temperature, real mass_s, real p_squared)
    {
        return (p_squared) * (k_boltzmann() * temperature) / (tritium_atomic_mass() + mass_s);
    }


// Finds variance due to a given rotation state J for a given isotopolog i (Eq. 38 in BPR)

    real find_sigma_squared_J_i(int J, real mass_s, real p_squared){
        real mu;    //Reduced mass of molecule
        real sigma_squared_J_i;
	real beta;
	real E_zp;

	sigma_squared_J_i <- 0.0;
	if (mass_s > 0.)
	{
            mu <- reduced_mass(mass_s, tritium_atomic_mass());
	    E_zp <- EZero_Point(mass_s);
	    beta <- (2.0*mu*E_zp/(3.0*tritium_atomic_mass()) + (2.* square(hbarc())*J*(J+1))/(3.0*square(bond_length_H2())*tritium_atomic_mass()));
            sigma_squared_J_i <- (p_squared/(2.0*tritium_atomic_mass()) * beta);
	}

        return sigma_squared_J_i;
        }


//  Finds coefficient that gives relative contribution of rotation state to variance for a given J
//  and a given isotopolog i (based on Eq. 16 in BPR and Doss (2007))

    real find_P_J_i(int J, real temperature, real mass_s, real lambda)
    {
        real Qo;
        real Qp;
	int nLimit;
        real Z_i;
        real P_J_i;

	nLimit <- 20;
        P_J_i <- 0.0;
	Z_i  <- 0.0;

        if (mass_s == tritium_atomic_mass()){
	    Qo <- 0.0;
            Qp <- 0.0;
	    for (i in 0:nLimit) {
	    	Qo <- Qo + f_heterogenous(2*i+1, temperature, mass_s);
	    	Qp <- Qp + f_heterogenous(  2*i, temperature, mass_s);
	    }
            Z_i <- (1.0-lambda)*Qp + lambda*Qo;

            if  (J % 2 == 0 || J == 0){
                P_J_i <- (1.0-lambda)*f_heterogenous(J, temperature, mass_s)/Z_i;
	    } else{
                P_J_i <- lambda*f_heterogenous(J, temperature, mass_s)/Z_i;
	    }
        } else if (mass_s > 0.0){
            for (j in 0:nLimit) Z_i <- Z_i + f_heterogenous(j, temperature, mass_s);
            P_J_i <- f_heterogenous(J, temperature, mass_s) / Z_i;
        }

        return P_J_i;
      }


// Finds rotational variance for a given isotopolog (summing over all rotation states)

    real find_sigma_squared_rotational(int num_J, real mass_s, real p_squared, real temperature, real lambda){
        real sigma_squared_rotational;

        sigma_squared_rotational <- 0.;
        for (n in 0:num_J){
            sigma_squared_rotational <- sigma_squared_rotational + find_P_J_i(n, temperature, mass_s, lambda)*find_sigma_squared_J_i(n, mass_s, p_squared);
        }
        return sigma_squared_rotational;
     }


// Finds total average standard deviation sigma_avg, accounting for translational and rotational effects

    real find_sigma(real temperature, real p_squared, real mass_s, int num_J, real lambda)
    {

    	real sigma_sq_rot;
    	real sigma_sq_trans;

	sigma_sq_rot <- find_sigma_squared_rotational(num_J, mass_s, p_squared, temperature, lambda);
	sigma_sq_trans <- find_sigma_squared_translational(temperature, mass_s, p_squared);

	return sqrt(sigma_sq_rot + sigma_sq_trans);

    }
